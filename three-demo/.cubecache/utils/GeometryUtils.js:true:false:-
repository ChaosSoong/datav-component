{"queryPath":"/utils/GeometryUtils.js","absPath":"/Users/william/Desktop/czb/datav-component/three-demo/utils/GeometryUtils.js","realPath":"/utils/GeometryUtils.js","type":"script","source":"/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\nvar THREE = require('three')\nTHREE.GeometryUtils = {\n\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\t// Get random point in triangle (via barycentric coordinates)\n\t// \t(uniform distribution)\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\n\trandomPointInTriangle: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvar point = new THREE.Vector3();\n\n\t\t\tvar a = Math.random();\n\t\t\tvar b = Math.random();\n\n\t\t\tif ( ( a + b ) > 1 ) {\n\n\t\t\t\ta = 1 - a;\n\t\t\t\tb = 1 - b;\n\n\t\t\t}\n\n\t\t\tvar c = 1 - a - b;\n\n\t\t\tpoint.copy( vectorA );\n\t\t\tpoint.multiplyScalar( a );\n\n\t\t\tvector.copy( vectorB );\n\t\t\tvector.multiplyScalar( b );\n\n\t\t\tpoint.add( vector );\n\n\t\t\tvector.copy( vectorC );\n\t\t\tvector.multiplyScalar( c );\n\n\t\t\tpoint.add( vector );\n\n\t\t\treturn point;\n\n\t\t};\n\n\t}(),\n\n\t// Get random point in face (triangle)\n\t// (uniform distribution)\n\n\trandomPointInFace: function ( face, geometry ) {\n\n\t\tvar vA, vB, vC;\n\n\t\tvA = geometry.vertices[ face.a ];\n\t\tvB = geometry.vertices[ face.b ];\n\t\tvC = geometry.vertices[ face.c ];\n\n\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t},\n\n\t// Get uniformly distributed random points in mesh\n\t// \t- create array with cumulative sums of face areas\n\t//  - pick random number from 0 to total area\n\t//  - find corresponding place in area array by binary search\n\t//\t- get random point in face\n\n\trandomPointsInGeometry: function ( geometry, n ) {\n\n\t\tvar face, i,\n\t\t\tfaces = geometry.faces,\n\t\t\tvertices = geometry.vertices,\n\t\t\til = faces.length,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC;\n\n\t\t// precompute face areas\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvA = vertices[ face.a ];\n\t\t\tvB = vertices[ face.b ];\n\t\t\tvC = vertices[ face.c ];\n\n\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[ i ] = totalArea;\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 );\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tvar stats = {};\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = Math.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry );\n\n\t\t\tif ( ! stats[ index ] ) {\n\n\t\t\t\tstats[ index ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tstats[ index ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\trandomPointsInBufferGeometry: function ( geometry, n ) {\n\n\t\tvar i,\n\t\t\tvertices = geometry.attributes.position.array,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC;\n\n\t\t// precompute face areas\n\t\tvA = new THREE.Vector3();\n\t\tvB = new THREE.Vector3();\n\t\tvC = new THREE.Vector3();\n\n\t\t// geometry._areas = [];\n\t\tvar il = vertices.length / 9;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tvA.set( vertices[ i * 9 + 0 ], vertices[ i * 9 + 1 ], vertices[ i * 9 + 2 ] );\n\t\t\tvB.set( vertices[ i * 9 + 3 ], vertices[ i * 9 + 4 ], vertices[ i * 9 + 5 ] );\n\t\t\tvC.set( vertices[ i * 9 + 6 ], vertices[ i * 9 + 7 ], vertices[ i * 9 + 8 ] );\n\n\t\t\ttotalArea += THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\tcumulativeAreas.push( totalArea );\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 );\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = Math.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\t// result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\t\t\tvA.set( vertices[ index * 9 + 0 ], vertices[ index * 9 + 1 ], vertices[ index * 9 + 2 ] );\n\t\t\tvB.set( vertices[ index * 9 + 3 ], vertices[ index * 9 + 4 ], vertices[ index * 9 + 5 ] );\n\t\t\tvC.set( vertices[ index * 9 + 6 ], vertices[ index * 9 + 7 ], vertices[ index * 9 + 8 ] );\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Get triangle area (half of parallelogram)\n\t// http://mathworld.wolfram.com/TriangleArea.html\n\n\ttriangleArea: function () {\n\n\t\tvar vector1 = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvector1.subVectors( vectorB, vectorA );\n\t\t\tvector2.subVectors( vectorC, vectorA );\n\t\t\tvector1.cross( vector2 );\n\n\t\t\treturn 0.5 * vector1.length();\n\n\t\t};\n\n\t}(),\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};","code":"'use strict';\n\nvar THREE = require('three');\nTHREE.GeometryUtils = {\n\n\tmerge: function merge(geometry1, geometry2, materialIndexOffset) {\n\n\t\tconsole.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');\n\n\t\tvar matrix;\n\n\t\tif (geometry2 instanceof THREE.Mesh) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\t\t}\n\n\t\tgeometry1.merge(geometry2, matrix, materialIndexOffset);\n\t},\n\n\trandomPointInTriangle: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function (vectorA, vectorB, vectorC) {\n\n\t\t\tvar point = new THREE.Vector3();\n\n\t\t\tvar a = Math.random();\n\t\t\tvar b = Math.random();\n\n\t\t\tif (a + b > 1) {\n\n\t\t\t\ta = 1 - a;\n\t\t\t\tb = 1 - b;\n\t\t\t}\n\n\t\t\tvar c = 1 - a - b;\n\n\t\t\tpoint.copy(vectorA);\n\t\t\tpoint.multiplyScalar(a);\n\n\t\t\tvector.copy(vectorB);\n\t\t\tvector.multiplyScalar(b);\n\n\t\t\tpoint.add(vector);\n\n\t\t\tvector.copy(vectorC);\n\t\t\tvector.multiplyScalar(c);\n\n\t\t\tpoint.add(vector);\n\n\t\t\treturn point;\n\t\t};\n\t}(),\n\n\trandomPointInFace: function randomPointInFace(face, geometry) {\n\n\t\tvar vA, vB, vC;\n\n\t\tvA = geometry.vertices[face.a];\n\t\tvB = geometry.vertices[face.b];\n\t\tvC = geometry.vertices[face.c];\n\n\t\treturn THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);\n\t},\n\n\trandomPointsInGeometry: function randomPointsInGeometry(geometry, n) {\n\n\t\tvar face,\n\t\t    i,\n\t\t    faces = geometry.faces,\n\t\t    vertices = geometry.vertices,\n\t\t    il = faces.length,\n\t\t    totalArea = 0,\n\t\t    cumulativeAreas = [],\n\t\t    vA,\n\t\t    vB,\n\t\t    vC;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tface = faces[i];\n\n\t\t\tvA = vertices[face.a];\n\t\t\tvB = vertices[face.b];\n\t\t\tvC = vertices[face.c];\n\n\t\t\tface._area = THREE.GeometryUtils.triangleArea(vA, vB, vC);\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[i] = totalArea;\n\t\t}\n\n\t\tfunction binarySearchIndices(value) {\n\n\t\t\tfunction binarySearch(start, end) {\n\n\t\t\t\tif (end < start) return start;\n\n\t\t\t\tvar mid = start + Math.floor((end - start) / 2);\n\n\t\t\t\tif (cumulativeAreas[mid] > value) {\n\n\t\t\t\t\treturn binarySearch(start, mid - 1);\n\t\t\t\t} else if (cumulativeAreas[mid] < value) {\n\n\t\t\t\t\treturn binarySearch(mid + 1, end);\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar result = binarySearch(0, cumulativeAreas.length - 1);\n\t\t\treturn result;\n\t\t}\n\n\t\tvar r,\n\t\t    index,\n\t\t    result = [];\n\n\t\tvar stats = {};\n\n\t\tfor (i = 0; i < n; i++) {\n\n\t\t\tr = Math.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices(r);\n\n\t\t\tresult[i] = THREE.GeometryUtils.randomPointInFace(faces[index], geometry);\n\n\t\t\tif (!stats[index]) {\n\n\t\t\t\tstats[index] = 1;\n\t\t\t} else {\n\n\t\t\t\tstats[index] += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\trandomPointsInBufferGeometry: function randomPointsInBufferGeometry(geometry, n) {\n\n\t\tvar i,\n\t\t    vertices = geometry.attributes.position.array,\n\t\t    totalArea = 0,\n\t\t    cumulativeAreas = [],\n\t\t    vA,\n\t\t    vB,\n\t\t    vC;\n\n\t\tvA = new THREE.Vector3();\n\t\tvB = new THREE.Vector3();\n\t\tvC = new THREE.Vector3();\n\n\t\tvar il = vertices.length / 9;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tvA.set(vertices[i * 9 + 0], vertices[i * 9 + 1], vertices[i * 9 + 2]);\n\t\t\tvB.set(vertices[i * 9 + 3], vertices[i * 9 + 4], vertices[i * 9 + 5]);\n\t\t\tvC.set(vertices[i * 9 + 6], vertices[i * 9 + 7], vertices[i * 9 + 8]);\n\n\t\t\ttotalArea += THREE.GeometryUtils.triangleArea(vA, vB, vC);\n\n\t\t\tcumulativeAreas.push(totalArea);\n\t\t}\n\n\t\tfunction binarySearchIndices(value) {\n\n\t\t\tfunction binarySearch(start, end) {\n\n\t\t\t\tif (end < start) return start;\n\n\t\t\t\tvar mid = start + Math.floor((end - start) / 2);\n\n\t\t\t\tif (cumulativeAreas[mid] > value) {\n\n\t\t\t\t\treturn binarySearch(start, mid - 1);\n\t\t\t\t} else if (cumulativeAreas[mid] < value) {\n\n\t\t\t\t\treturn binarySearch(mid + 1, end);\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar result = binarySearch(0, cumulativeAreas.length - 1);\n\t\t\treturn result;\n\t\t}\n\n\t\tvar r,\n\t\t    index,\n\t\t    result = [];\n\n\t\tfor (i = 0; i < n; i++) {\n\n\t\t\tr = Math.random() * totalArea;\n\n\t\t\tindex = binarySearchIndices(r);\n\n\t\t\tvA.set(vertices[index * 9 + 0], vertices[index * 9 + 1], vertices[index * 9 + 2]);\n\t\t\tvB.set(vertices[index * 9 + 3], vertices[index * 9 + 4], vertices[index * 9 + 5]);\n\t\t\tvC.set(vertices[index * 9 + 6], vertices[index * 9 + 7], vertices[index * 9 + 8]);\n\t\t\tresult[i] = THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\ttriangleArea: function () {\n\n\t\tvar vector1 = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\n\t\treturn function (vectorA, vectorB, vectorC) {\n\n\t\t\tvector1.subVectors(vectorB, vectorA);\n\t\t\tvector2.subVectors(vectorC, vectorA);\n\t\t\tvector1.cross(vector2);\n\n\t\t\treturn 0.5 * vector1.length();\n\t\t};\n\t}(),\n\n\tcenter: function center(geometry) {\n\n\t\tconsole.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');\n\t\treturn geometry.center();\n\t}\n\n};","codeWraped":"Cube(\"/utils/GeometryUtils.js\", [\"/node_modules/three/build/three.js\"], function (module, exports, require, load, process, global) {\n\n  var THREE = require('/node_modules/three/build/three.js');\n  THREE.GeometryUtils = {\n\n    merge: function merge(geometry1, geometry2, materialIndexOffset) {\n\n      console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');\n\n      var matrix;\n\n      if (geometry2 instanceof THREE.Mesh) {\n\n        geometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n        matrix = geometry2.matrix;\n        geometry2 = geometry2.geometry;\n      }\n\n      geometry1.merge(geometry2, matrix, materialIndexOffset);\n    },\n\n    randomPointInTriangle: function () {\n\n      var vector = new THREE.Vector3();\n\n      return function (vectorA, vectorB, vectorC) {\n\n        var point = new THREE.Vector3();\n\n        var a = Math.random();\n        var b = Math.random();\n\n        if (a + b > 1) {\n\n          a = 1 - a;\n          b = 1 - b;\n        }\n\n        var c = 1 - a - b;\n\n        point.copy(vectorA);\n        point.multiplyScalar(a);\n\n        vector.copy(vectorB);\n        vector.multiplyScalar(b);\n\n        point.add(vector);\n\n        vector.copy(vectorC);\n        vector.multiplyScalar(c);\n\n        point.add(vector);\n\n        return point;\n      };\n    }(),\n\n    randomPointInFace: function randomPointInFace(face, geometry) {\n\n      var vA, vB, vC;\n\n      vA = geometry.vertices[face.a];\n      vB = geometry.vertices[face.b];\n      vC = geometry.vertices[face.c];\n\n      return THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);\n    },\n\n    randomPointsInGeometry: function randomPointsInGeometry(geometry, n) {\n\n      var face,\n      i,\n      faces = geometry.faces,\n      vertices = geometry.vertices,\n      il = faces.length,\n      totalArea = 0,\n      cumulativeAreas = [],\n      vA,\n      vB,\n      vC;\n\n      for (i = 0; i < il; i++) {\n\n        face = faces[i];\n\n        vA = vertices[face.a];\n        vB = vertices[face.b];\n        vC = vertices[face.c];\n\n        face._area = THREE.GeometryUtils.triangleArea(vA, vB, vC);\n\n        totalArea += face._area;\n\n        cumulativeAreas[i] = totalArea;\n      }\n\n      function binarySearchIndices(value) {\n\n        function binarySearch(start, end) {\n\n          if (end < start) return start;\n\n          var mid = start + Math.floor((end - start) / 2);\n\n          if (cumulativeAreas[mid] > value) {\n\n            return binarySearch(start, mid - 1);\n          } else if (cumulativeAreas[mid] < value) {\n\n            return binarySearch(mid + 1, end);\n          } else {\n\n            return mid;\n          }\n        }\n\n        var result = binarySearch(0, cumulativeAreas.length - 1);\n        return result;\n      }\n\n      var r,\n      index,\n      result = [];\n\n      var stats = {};\n\n      for (i = 0; i < n; i++) {\n\n        r = Math.random() * totalArea;\n\n        index = binarySearchIndices(r);\n\n        result[i] = THREE.GeometryUtils.randomPointInFace(faces[index], geometry);\n\n        if (!stats[index]) {\n\n          stats[index] = 1;\n        } else {\n\n          stats[index] += 1;\n        }\n      }\n\n      return result;\n    },\n\n    randomPointsInBufferGeometry: function randomPointsInBufferGeometry(geometry, n) {\n\n      var i,\n      vertices = geometry.attributes.position.array,\n      totalArea = 0,\n      cumulativeAreas = [],\n      vA,\n      vB,\n      vC;\n\n      vA = new THREE.Vector3();\n      vB = new THREE.Vector3();\n      vC = new THREE.Vector3();\n\n      var il = vertices.length / 9;\n\n      for (i = 0; i < il; i++) {\n\n        vA.set(vertices[i * 9 + 0], vertices[i * 9 + 1], vertices[i * 9 + 2]);\n        vB.set(vertices[i * 9 + 3], vertices[i * 9 + 4], vertices[i * 9 + 5]);\n        vC.set(vertices[i * 9 + 6], vertices[i * 9 + 7], vertices[i * 9 + 8]);\n\n        totalArea += THREE.GeometryUtils.triangleArea(vA, vB, vC);\n\n        cumulativeAreas.push(totalArea);\n      }\n\n      function binarySearchIndices(value) {\n\n        function binarySearch(start, end) {\n\n          if (end < start) return start;\n\n          var mid = start + Math.floor((end - start) / 2);\n\n          if (cumulativeAreas[mid] > value) {\n\n            return binarySearch(start, mid - 1);\n          } else if (cumulativeAreas[mid] < value) {\n\n            return binarySearch(mid + 1, end);\n          } else {\n\n            return mid;\n          }\n        }\n\n        var result = binarySearch(0, cumulativeAreas.length - 1);\n        return result;\n      }\n\n      var r,\n      index,\n      result = [];\n\n      for (i = 0; i < n; i++) {\n\n        r = Math.random() * totalArea;\n\n        index = binarySearchIndices(r);\n\n        vA.set(vertices[index * 9 + 0], vertices[index * 9 + 1], vertices[index * 9 + 2]);\n        vB.set(vertices[index * 9 + 3], vertices[index * 9 + 4], vertices[index * 9 + 5]);\n        vC.set(vertices[index * 9 + 6], vertices[index * 9 + 7], vertices[index * 9 + 8]);\n        result[i] = THREE.GeometryUtils.randomPointInTriangle(vA, vB, vC);\n      }\n\n      return result;\n    },\n\n    triangleArea: function () {\n\n      var vector1 = new THREE.Vector3();\n      var vector2 = new THREE.Vector3();\n\n      return function (vectorA, vectorB, vectorC) {\n\n        vector1.subVectors(vectorB, vectorA);\n        vector2.subVectors(vectorC, vectorA);\n        vector1.cross(vector2);\n\n        return 0.5 * vector1.length();\n      };\n    }(),\n\n    center: function center(geometry) {\n\n      console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');\n      return geometry.center();\n    } };return module.exports;});","sourceMap":null,"modifyTime":1554345712034,"mime":"application/javascript","wrap":true,"skip":false,"compress":false,"ext":".js","targetExt":".js","loads":[],"originalLoads":[],"requires":["/node_modules/three/build/three.js"],"requiresOrigin":["/node_modules/three/build/three.js"],"debugInfo":[],"requiresArgsRefer":[{"type":"StringLiteral","start":35,"end":42,"loc":{"start":{"line":3,"column":20},"end":{"line":3,"column":27}},"extra":{"rawValue":"three","raw":"'three'"},"value":"/node_modules/three/build/three.js"}]}